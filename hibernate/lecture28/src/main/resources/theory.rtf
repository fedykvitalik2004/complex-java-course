1. Коли звʼязок one-to-one, то можна реалізувати його декількома способами. Перший спосіб - це
в одній таблиці є PM, а в другій є FK, що посилається на цей PK, який є унікальним. Можна, по суті,
реалізувати це з двох боків, тобто двома способами, проте краще робити на стороні дитини, щоб було
більш читабельно у батька.
2. @JoinColumn краще ставити для перевірки.
3. Конструктори потрібні для отримання даних із БД.
4. У many-to-many звʼязку немає батьків, по суті, але потрібно все-таки обрати сторону для батька в Java, якщо використовувати bidirectional.
Окрім цього, також можна unidirectional. Ще можна робити через додатковий клас.
5. "Update" в persistence.xml є недоробленим.
6. У many-to-many краще мапінг робити на обох сторонах. Якщо є на одній лише, то в деяких моментах при видалені сутності із List чи Set
будуть видалятися записи в проміжній таблиці, а потім додаватися знову т.д.
7. Операція merge повинна бути в транзакції, і потрібна для оновлення даних.
8. Є self-joining one-to-many (у таблиці є FK, що посилається на PK тієї ж таблиці) та many-to-many (потрібно
2 таблиці: у проміжній (2) таблиці є складений ключ, частини яких посилаються на 1 таблицю). Є декілька способів, включаючи unidirectional
та bidirectional (наприклад, хто є моїми друзями, та чиїми друзями я є), а також можна створити додаткову сутність в Java.
9. Якщо звʼязок to-many, то за замовчуванням не вигружається одразу, а якщо to-one, то - одразу. Ця опція вказується fetch.
Якщо тип eager, то не завжди буде поєднуватися із початковим запитом, а буде як окремий.
10. Потрібно знайти баланс між тим, що в БД має йти менше запитів, та щоб не вигружало багато даних.
11. Hypersistence optimizer може допомогти вирішити проблеми із Hibernate.
12. Можна використовувати Criteria API та Entity Graphs.
1. Основна ідея ORM - це працювати із БД як з обʼєктами. Окрім того, можна використовувати JDBC, для використання якого потрібно
створювати запити, та результат якого буде ResultSet, який є таблицею. Значно легше видаляти, додавати, оновлювати, отримувати,
писати складніший запит, використовуючи поля, навіть заблокувати (lock). Задача ORM перетворювати обʼєкти в SQL запити,
які будуть транслювати зміни, та навпаки. По суті, це трансформація між двома моделями: таблицями та обʼєктами. Спосіб
збереження даних за допомогою JDBC та Hibernate різний. І також варто зауважити, що обʼєкти зберігаються в оперативній
памʼяті, тому звʼязки будуються за допомогою посилань (інших обʼєктів). Нашаровуються технології
під час роботи із ORM. ORM працює на рефлексії.
2. Термін ORM є загальним, і його використовують у різних мовах програмування. JPA - це специфікація (описано як працювати
із даними) (частина Java EE), у той час як Hibernate - це реалізація. Можна працювати із БД через JDBC та Hibernate. Якщо
працювати із Hibernate, то одним із способів є написання конфігурації в META-INF/persistence.xml. Для роботи із JDBC спочатку
створюється обʼєкт DataSource, якому передаються credentials, і цей обʼєкт дає Connection-обʼєкт. У Hibernate потрібно створювати
EntityManagerFactory, але при цьому також мають бути дані необхідні для роботи.
3. У документації до Hibernate вказано, що можна робити через класи від Hibernate, проте краще використовувати від JPA,
оскільки це специфікація. Це дає більше гнучкості. Spring Data JPA використовує Hibernate, але при цьому дотримуються
JPA специфікації. Також у документації можна детальніше прочитати про архітектуру, анотації і т.д.
Data    Access    Layer
|                     |
v                     v
Java          Hibernate
Persistence      Native
API                 API
          |
          v
      Hibernate
          |
          v
         JDBC
          |
          v
          DB

EntityManagerFactory (JPA) <= SessionFactory <= SessionFactoryImpl - це потокозахищена фабрика сесій. Потрібна для того, щоб
можна було отримати сесію.
EntityManager (JPA) <= Session <= SessionFactory - це сесія роботи із БД, яка дає API, за допомогою якої можна взаємодіяти. ЇЇ
потрібно закривати. У Spring'у це автоматично закривається.
EntityTransaction (JPA) <= Transaction <= TransactionImpl
Тут слово "Entity" міститься, оскільки вони працюють із ними.
4. Можна зробити шаблон для генерації коду (Live Templates). Можна додати код, навіть додати змінні та вказати для яких файлів.
5. Persistence Unit - це обʼєднання налаштувань для фабрики. У проєкті таке не використовується. Може бути їх декілька. Можна реалізувати аналог
через Java, використовуючи клас HibernatePersistenceProvider.
7. Специфікація та реалізація. У Java таких комбінацій багато.
JDBC API - JDBC Driver
Servlet API - TomCat
JPA - Hibernate
8. Hibernate - це як маппер.
9. Операцію read можна робити не в транзакції, тим часом, як всі решта - в транзакції, але бажано,щоб завжди була, не
використовуючи autoCommit.
10. JPA (від Jakarta та JavaEE) є майже однаковими, проте зараз не використовується JavaEE у нових версіях. JPA - це J*
Persistence API. Починаючи із 6 версії Hibernate, використовуються від Jakarta усередині пакету. І драйвер також інший.
11. Фундаментальні принципи полегшують сприйняття та подальшого розвитку.